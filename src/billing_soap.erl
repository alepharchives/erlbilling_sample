-module(billing_soap).
-author("Serge Ziryukin <ftrvxmtrx@gmail.com>").
-behaviour(gen_server).

-export([soap_op/1]).

-export([start/0, init/1,
         handle_call/3, handle_cast/2, handle_info/2,
         terminate/2, code_change/3]).

%% these are generated by erlsom (using write_hrl)
-record('in:CancelTransactionArgs', {anyAttribs, 'TransactionID'}).
-record('in:ChargeAmountArgs', {anyAttribs, 'AccountNumber', 'Amount'}).
-record('in:ConfirmTransactionArgs', {anyAttribs, 'TransactionID'}).
-record('in:RefillAmountArgs', {anyAttribs, 'AccountNumber', 'Amount'}).
-record('in:ReserveAmountArgs', {anyAttribs, 'AccountNumber', 'Amount'}).
-record('out:Result', {anyAttribs, 'Result'}).
-record('out:TransactionID', {anyAttribs, 'TransactionID'}).
-record('sp:Body', {anyAttribs, choice}).
-record('sp:Envelope', {anyAttribs, 'Header', 'Body'}).
-record('sp:Fault', {anyAttribs, 'Code', 'Reason', 'Node', 'Role', 'Detail'}).
%-record('sp:Header', {anyAttribs, choice}).
%-record('sp:NotUnderstoodType', {anyAttribs, 'qname'}).
%-record('sp:SupportedEnvType', {anyAttribs, 'qname'}).
%-record('sp:UpgradeType', {anyAttribs, 'SupportedEnvelope'}).
%-record('sp:detail', {anyAttribs, choice}).
-record('sp:faultcode', {anyAttribs, 'Value', 'Subcode'}).
-record('sp:faultreason', {anyAttribs, 'Text'}).
-record('sp:reasontext', {anyAttribs, 'P:lang', '#text'}).
%-record('sp:subcode', {anyAttribs, 'Value', 'Subcode'}).

%% we store both models in module's state for soap handling
-record(state, {model_in, model_out}).

start() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).

soap_op(Xml) ->
    gen_server:call(?MODULE, {'soap_op', Xml}).

filename(Name) ->
    code:where_is_file(Name).

init(_Args) ->
    EnvelopeXsd = filename("soap.xsd"),
    BodyXsd = filename("soap_in.xsd"),
    ResultXsd = filename("soap_out.xsd"),
    {ok, SoapModel} = erlsom:compile_xsd_file(EnvelopeXsd, [{prefix, "sp"}]),
    {ok, ModelIn} = erlsom:add_xsd_file(BodyXsd, [{prefix, "in"}], SoapModel),
    {ok, ModelOut} = erlsom:add_xsd_file(ResultXsd, [{prefix, "out"}], SoapModel),
    {ok, #state{model_in = ModelIn, model_out = ModelOut}}.

%% @doc Generate SOAP body.
soap_body(Data) ->
    #'sp:Envelope'{'Body' = #'sp:Body'{choice = Data}}.

%% @doc Generate error response.
soap_error(Code, Reason) ->
    FaultCode = #'sp:faultcode'{'Value' = Code},
    ReasonRec = #'sp:faultreason'{'Text' = [#'sp:reasontext'{'P:lang' = "EN", '#text' = Reason}]},
    soap_body([#'sp:Fault'{'Code' = FaultCode, 'Reason' = ReasonRec}]).

%% @doc Generate SOAP response according to db server answers.
soap_response(Result) ->
    case Result of
        {ok, ok} ->
            soap_body([#'out:Result'{'Result' = "E_SUCCESS"}]);
        {ok, TransactionID} ->
            soap_body([#'out:TransactionID'{'TransactionID' = TransactionID}]);
        {fail, invalid_account} ->
            soap_error("E_INVALIDACCOUNT", "Invalid account");
        {fail, insufficient_credit} ->
            soap_error("E_INSUFFICIENTCREDIT", "Insufficient credit");
        {fail, transaction_not_found} ->
            soap_error("E_TRANSACTIONNOTFOUND", "Transaction not found");
        {fail, wrong_transaction_status} ->
            soap_error("E_WRONGTRANSACTIONSTATUS", "Wrong transaction status")
    end.

%% @doc Process SOAP request and generate the response.
process_data(Data) ->
    case Data of
        [#'in:CancelTransactionArgs'{'TransactionID' = TransactionID}] ->
            soap_response(billing_db:cancel_transaction(TransactionID));
        [#'in:ChargeAmountArgs'{'AccountNumber' = AccountNumber, 'Amount' = Amount}] ->
            soap_response(billing_db:charge_amount(AccountNumber, Amount));
        [#'in:ConfirmTransactionArgs'{'TransactionID' = TransactionID}] ->
            soap_response(billing_db:confirm_transaction(TransactionID));
        [#'in:RefillAmountArgs'{'AccountNumber' = AccountNumber, 'Amount' = Amount}] ->
            soap_response(billing_db:refill_amount(AccountNumber, Amount));
        [#'in:ReserveAmountArgs'{'AccountNumber' = AccountNumber, 'Amount' = Amount}] ->
            soap_response(billing_db:reserve_amount(AccountNumber, Amount));
        _ ->
            soap_error("E_INTERNALERROR", "Bad SOAP request")
    end.

handle_call({'soap_op', Xml}, _From, State = #state{model_in = ModelIn, model_out = ModelOut}) ->
    Response = case erlsom:scan(Xml, ModelIn) of
                   {ok, #'sp:Envelope'{'Body' = #'sp:Body'{choice = Data}}, _} ->
                       process_data(Data);
                   {error, _} ->
                       soap_error("E_INTERNALERROR", "Bad SOAP envelope")
               end,
    Result = erlsom:write(Response, ModelOut),
    {reply, Result, State}.

handle_cast(_Msg, State) ->
    {noreply, State}.

handle_info(_Msg, State) ->
    {noreply, State}.

terminate(_Reason, _State) ->
    ok.

code_change(_OldVersion, State, _Extra) ->
    {ok, State}.
